# 算法
从1+2+……+100，两种算法比较
```
int i, sum = 0, n = 100;
for(i = 1; i <= n; i++) {
    sum = sum + i;
}
```

```
int i, sum = 0, n = 100;
sum = (1 + n) * n / 2;
```

## 什么是算法
算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或者多个操作。

程序的本质，就是用算法来处理数据结构。

## 算法的特性
- 有固定的输入输出
- 有穷性
- 确定性
- 可行性

## 算法的设计
- 正确性
- 效率高和存储低
- 可读性与防御性（健壮性）

## 算法效率度量
- 事后统计法
主要通过设计好的测试程序与数据，利用计算机对程序的运行时间进行比较，从而确定算法效率的高低。

但是这种方法显然有很大缺陷：
    - 需要花费大量时间与精力来编写算法，而编制后发现是很糟糕的算法，等于竹篮子打水一场空。
    - 时间比较依赖计算机硬件、软件环境。cup与内存性能不一样，时间会有差异。
    - 算法的测试数据设计困难，效率高的算法在小的数据面前往往得不到体现。比如10以内的数据排序，不管用什么算法，差异几乎为0。而如果测试数据大于一百万，那么不同算法的差异就很大了。为了比较算法，到底用多少数据，很难判断。

所以事后统计法往往不予采纳。

- 事件分析评估方法
高级程序语言编写的程序在计算机上运行的消耗时间取决于以下因素：
1. 问题的规模
1. 算法策略、方法
1. 编译的代码质量
1. 机器执行指令的速度

第三条取决于软件，第四条取决于计算机硬件。也就是说，除了软硬件的有关因素，**程序运行的时间,依赖于问题的规模以及算法的质量**

### 度量例子
第一种算法
```
int i, sum = 0, n = 100;        /* 执行1次*/
for(i = 1; i <= n; i++) {       /* 执行了n+1次*/
    sum = sum + i;              /* 执行n次*/
}
```

第二种算法
```
int i, sum = 0, n = 100;        /*执行1次*/
sum = (1 + n) * n / 2;          /*执行1次*/
```

显而易见，算法的差异就是1次与n次的差异。

### 度量
我们不关心程序的设计语言是什么，也不关心跑在什么机器上，我们只关心它所实现的算法。除去变量声明、打印结果等操作。**最终，分析程序的运行时间时，最重要的是把程序看成独立于程序语言的算法或者一系列步骤**

第一种方法的输入规模n与操作数量f(n)的关系是
```
f(n)=n
```
第二种：
```
f(n)=1
```
如果出现双重循环，关系是这样：
```
fn(n)=n平方
```

**在分析算法的运行时间时，重要的是把基本操作的数量与输入规模关联起来，基本操作的数量必须标示输入规模的函数。**

## 函数渐进增长
算法A要做2n + 3次操作，算法B做3n + 1次操作。那么他们哪个快呢？在不同输入规模的情况下，答案是不同的。

所以我们在考虑时间时，要忽略这些加法常数与最高次项的乘法常数。随着指数的增长，时间增长的特别快。

**判断一个算法的效率时，函数的常数与其他次要项的乘数可以忽略，更应该关注最高阶项的阶数。**

**某些算法，随着n的增大，越来越优（差）于另一种算法。**

## 算法时间复杂度
**在进行算法分析时，语句总执行次数是关于问题规模n的函数，进而分析T(n)随着n的变化情况来确定T(n)的数量级。算法的时间复杂度，记作：T(n) = O(f(n))。随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称为算法的渐进时间复杂度，简称时间复杂度。其中f(n)是问题规模n的某个函数。**

通过大写O()来体现算法时间复杂度的记法，称为大O记法。

**随着n增大，T(n)增加最慢的算法叫做最优算法。**

我们三种求和的时间复杂度分别为O(n),O(1),O(n方)。分别叫做常数阶，线性阶，平方阶。

## 推导时间复杂度的方法
1. 用常数1取代运行时间所有加法常数。
2. 只保留最高阶项。
3. 如果最高阶存在且阶数并不为1，去除与之相乘的常数。

### 常数阶
```
int num = 0, n = 100;  /*执行1次*/
sum = (1 + n) * n / 2; /*执行1次*/
```
时间复杂度为`f(n)=2`，第一步是用常数1取代2。在保留最高阶项时发现没有最高阶，所以算法的时间复杂度为O(1)。

### 对数阶
```
int count = 1;
while (count < n) {
    count = count * 2;
}
```
2的x次方=n，得出x=log(2)n。所以这个循环的时间复杂度为O(log(n))

### 高阶
循环记作O(n)，二层嵌套循环记作O(n方)。当嵌套层数不固定，就成了指数阶，记作O(n的n次方)

## 常见时间复杂度
```
O(1)<O(log(n))<O(n)<O(nlog(n))<O(n方)<O(n立方)<O(2的n方)<O(n!)<O(n的n方)
```

## 最好与最坏运行时间
比如运行一个循环，可能第一次就查找到了，那么时间复杂度为O(1),也可能运行到最后才查找到，时间复杂度为O(n)，我们称之为最坏运行时间，没有比这再长的时间了，通常我们所说的时间复杂度都是最坏时间复杂度。

## 空间复杂度
比如我们要判断某某年是不是润年。第一种是每次都要计算来获得结果，第二种方法是事先建立2050个长度的数组（有可能会多一些），把每年的闰年情况放进去。这样计算时候，就变成了查找数组某一项值的问题，优化了时间复杂度，但是硬盘上需要存储2050个0/1区分是否是闰年。

**算法的空间复杂度计算公式为S(n)=O(f(n)),n为问题规模，f(n)语句关于n所占用存储空间的函数**

通常我们说的复杂度，是指时间复杂度。